<html>
	<head>
		<title>
		</title>
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
		<script>
			var util = (function() {

				function equilateralBToH(b) {
					return Math.floor(Math.sqrt(3) * b / 2);
				}

				return {
					equilateralBToH: equilateralBToH
				}
			})();

			Function.prototype.inheritsFrom = function( parentClassOrObject ){ 
				if ( parentClassOrObject.constructor == Function ) 
				{ 
					//Normal Inheritance 
					this.prototype = new parentClassOrObject;
					this.prototype.constructor = this;
					this.prototype.parent = parentClassOrObject.prototype;
				} 
				else 
				{ 
					//Pure Virtual Inheritance 
					this.prototype = parentClassOrObject;
					this.prototype.constructor = this;
					this.prototype.parent = parentClassOrObject;
				} 
				return this;
			} 

			// invoke parent constructor of this
			function Super(obj) {
				if (obj.parent) return obj.parent.constructor;
			}

			function CanvasState(canvas) {
				this.canvas = canvas;
				this.width = canvas.width;
				this.height = canvas.height;
				this.ctx = canvas.getContext('2d');

				this.valid = false; // when set to true, canvas will redraw
				this.shapes = [];
				this.interval = 30; // redraw time

				var self = this;

				// redraw
				setInterval(function() {
					self.draw();	
				}, self.interval);
			}

			CanvasState.prototype.redraw = function() {
				this.valid = false;
				
				// force redraw. if we don't, we delegate drawing scheduling back to CanvasState timer
				// this.draw();
			}

			CanvasState.prototype.draw = function() {
				if (!this.valid)  {
					var ctx = this.ctx;
					var shapes = this.shapes;
					this.clear();

					for (var i = 0 ; i < shapes.length; i++) {
						var shape = shapes[i];
						if (shape.x > this.width || shape.y > this.height ||
							shape.x + shape.w < 0 || shape.y + shape.h < 0) continue;

						shapes[i].draw(ctx);
					}
					// draw selection
				    // right now this is just a stroke along the edge of the selected Shape
				    if (this.selection != null) {
				      ctx.strokeStyle = this.selectionColor;
				      ctx.lineWidth = this.selectionWidth;
				      var mySel = this.selection;
				      ctx.strokeRect(mySel.x,mySel.y,mySel.w,mySel.h);
				    }

				    this.valid = true;
				}
			}
			CanvasState.prototype.addShape = function(shape) {
			  this.shapes.push(shape);
			  this.valid = false;
			}
			CanvasState.prototype.clear = function() {
			  this.ctx.clearRect(0, 0, this.width, this.height);
			}

			// Triangle
			function Shape(x, y, color) {
				this.x = x || 0;
				this.y = y || 0;
				this.color = color || '#8e44ad';
			}
			Shape.prototype.draw = function(ctx) {

			}

			Square.inheritsFrom(Shape);
			function Square(x, y, color, w) {
				Super(this).call(this, x, y, color);
				this.w = w;
			}
			Square.prototype.draw = function(ctx) {
				ctx.fillStyle = this.color;
				ctx.beginPath();
				ctx.fillRect(this.x, this.y, this.w, this.w);
			}

			// Upside Down Triangle
			Triangle.inheritsFrom(Shape);
			// Constructor
			function Triangle(x, y, b, color, num) {
				// Invoke Super
				Super(this).call(this, x, y, color);
				this.b = b;
				this.h = util.equilateralBToH(b);
				this.num = num;
			}
			Triangle.prototype.draw = function(ctx) {
				ctx.fillStyle = this.color;
				ctx.beginPath();
				ctx.moveTo(this.x + 0, this.y + this.h);
				ctx.lineTo(this.x + this.b, this.y + this.h);
				ctx.lineTo(this.x + (this.b/2), this.y + 0);
				ctx.fill();

				ctx.fillStyle = "white";
				ctx.font = "12px Arial";
				ctx.fillText(this.num, this.x + this.b/2 - 6, this.y + this.h/2 +12);
			}

			function Tile(x, y, size, color, canvas) {
				this.shape = new Square(x, y, color, size);

				// delegate redrawing management to canvas
				canvas.addShape(this.shape);
			}
			Tile.prototype.change = function(x) {
				this.shape.x += x
			}

			function Grid(canvas) {
				this.canvasState = canvas;
				this.tiles = [];

				var NUM_ROWS = 10;
				var NUM_COLS = 10;
				var TILE_SIZE = 50;
				for(var i = 0; i < NUM_COLS; i++) {
					for (var j = 0; j < NUM_ROWS; j++) {
						var color = (i + j) % 2 === 0 ? "#FF0000" : "#000000";

						this.tiles.push(new Tile(TILE_SIZE*i, TILE_SIZE*j, TILE_SIZE, color, canvas));
					}
				}
			}
			// Updates the grid. And redraw
			Grid.prototype.update = function() {
				this.canvasState.redraw();
			}

			$(document).ready(function() {

				var canvas = new CanvasState(document.getElementById("game"));

				var g = new Grid(canvas);

				setInterval(function() {
					g.update();
				}, 50);
			});
		</script>
		<style>
		</style>
	</head>
	<body>
		
		<canvas id="game" width="800" height="600">
			This text is displayed if your browser does not support HTML5 Canvas.
		</canvas>
	</body>
</html>